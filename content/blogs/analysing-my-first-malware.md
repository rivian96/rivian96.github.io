+++
title = "Analysing My First Malware"
date = 2024-11-03T09:32:31-05:00
draft = false
+++

This /////blogs

/

/

/

 goes through the main phases of malware analysis which includes:
static analysis, behaviour analysis,emulation techniques and code analysis.

# brbbot Network Activities

![DNS Query Image](///////blogs

/

/

/

/

first-malware/image-20241020115414-3yrfrr7.png)

**DNS Query (Frame 7)**

The source IP `192.168.44.129` sends a DNS query to `192.168.44.128` (likely a DNS server) asking for the IP address corresponding to the domain `brb.3dtuts.by`.

* Query ID: `0xf0a8`

  **Purpose of Query ID (0xf0a8)**

  **Uniqueness**: Each DNS query has a unique Query ID to differentiate it from other queries sent to the DNS server. This helps the server and the client identify which response corresponds to which query, especially when multiple queries are sent simultaneously.

  **Matching Responses**: When a client sends a DNS query to a server, it includes this Query ID in the message. The server then includes the same Query ID in its response. This way, the client can match the response to its original query.

* DNS Query Type: `A` (a request for the IPv4 address of the domain).

---

**ICMP Destination Unreachable (Frame 8)**

The client receives an ICMP message from the DNS server indicating that it cannot reach the requested port (likely port 80 for HTTP). The message states "Destination unreachable (Port unreachable)," meaning that the client attempted to communicate with a port on the server that is not open or does not have a service listening.


<span data-type="text" style="font-size: 19px;">So, I started a fake DNS server on my remnux VM, and then again captured the network traffic using Wireshark.</span>

![Wireshark Traffic 1](///////blogs

/

/

/

/

first-malware/image-20241020122935-hwm16h1.png)

![Wireshark Traffic 2](///////blogs

/

/

/

/

first-malware/image-20241020123026-gnu67kl.png)

![Wireshark Traffic 3](///////blogs

/

/

/

/

first-malware/image-20241020123130-sj6lyd6.png)

**Let's See the Wireshark Traffic Now**

![Wireshark Analysis](///////blogs

/

/

/

/

first-malware/image-20241020121549-ea3rtot.png)

* The client (`192.168.44.129`) successfully resolves the domain `brb.3dtuts.by` to the IP `192.168.44.128` via DNS.
* After resolving the IP, the client tries to initiate a TCP connection to the server on port 80 (HTTP).
* However, the server immediately resets the connection (RST) both times, preventing any successful connection from being established.

*Because there's no HTTP server running on port 80.*

<span data-type="text" style="font-size: 22px; color: var(--b3-font-color3);">So let's start our HTTP server running on port 80.</span>

![HTTP Server Start](///////blogs

/

/

/

/

first-malware/image-20241020122059-aykw4ja.png)

![HTTP Traffic](///////blogs

/

/

/

/

first-malware/image-20241020122013-59980dl.png)

* The client (`192.168.44.129`) successfully resolves the domain `brb.3dtuts.by` via DNS.
* After that, the client initiates a TCP connection to the server at `192.168.44.128` on port 80, and the TCP three-way handshake is completed successfully.
* The client then sends an HTTP GET request for a resource, but the server responds with a 404 Not Found, indicating that the resource does not exist.
* After responding, the server and client go through the TCP connection teardown process, with the server closing the connection first, followed by the client.

**HTTP GET Request (Frame 80)**

* The client sends an HTTP GET request to the server, requesting a resource (`/ads.php?...`).
* This GET request contains a long query string with various parameters.

![GET Request Details](///////blogs

/

/

/

/

first-malware/image-20241020122525-kfwyiin.png)

---

# brbbot Binary Emulation

![image](///////blogs

/

/

/

/

first-malware/image-20241016145558-tihfv6h.png)

**What is an emulator?**

An emulator pretends to run a program and tells you what the program will do if it really ran. That's what we are going to do now with the malware `brbbot.exe`. Emulators are helpful because they give you an idea of where you might want to look first, especially if you want to do some code analysis. Emulators will especially let you know what API calls are being made. API calls are very critical for malware analysis; just by looking at them, we can get some idea about what exactly the malware is trying to do.

Some malware samples will hide the API calls that they're making. So emulators can help you detect what API calls the malware makes, even if you cannot see them at static analysis time. However, emulators don’t do everything. There are some emulators already installed on Remnux (Speakeasy, Capa, Binee, Qiling, Vivisect). Let’s look at some of these.

![image](///////blogs

/

/

/

/

first-malware/image-20241016145857-ck1xvkw.png)

```
run_speakeasy.py -t brbbot.exe -o speakeasy.json 2> speakeasy.txt

```

![image](///////blogs

/

/

/

/

first-malware/image-20241016150033-jya37u9.png)

The output could be overwhelming:

![image](///////blogs

/

/

/

/

first-malware/image-20241016150222-4kvswsp.png)

As you scroll through the `speakeasy.txt` file in Visual Studio Code, note the **first CreateFileA API call**, which attempts to open a handle to `brbconfig.tmp` with the ability to read from and write to that handle. The statement `-> 0x80` at the end of that line indicates that the emulator assigns handle number `0x80` to that handle.

**File handle** is just a number that identifies that file.

Two lines later, note the **WriteFile API call**, which specifies handle `0x80` as the destination of the operation. That's the handle from the earlier `CreateFileA` call, which suggests that the specimen would try to write to `brbconfig.tmp` if it were running in a real environment (note the inclusion of `GENERIC_WRITE` and `CREATE_ALWAYS` flags).

A bit later, the output of Speakeasy includes another instance of **CreateFileA**, which is also directed at `brbconfig.tmp`. In this case, the specimen expects to open an existing file (note the `OPEN_EXISTING` flag). This is probably an attempt to read the generated `brbconfig.tmp` file so that the specimen can examine its contents. (Despite its name, `CreateFileA` can be used to not only create a new file but also open an existing file).

![image](///////blogs

/

/

/

/

first-malware/image-20241016150136-tpmdfnu.png)

**Unsupported API: ADVAPI32.CryptDeriveKey**: This message indicates that Speakeasy encountered an unfamiliar API call (`CryptDeriveKey`), which it couldn't emulate. Unsure how to proceed, the emulator halted without giving us visibility into what the specimen would have done calling `CryptDeriveKey`. This is a common limitation of emulators.

```
jq -r '.. | .api_name?' speakeasy.json | sort -u | less

```

![image](///////blogs

/

/

/

/

first-malware/image-20241016150503-6d3exaw.png)

This way, we have collected the API names used by this program.

![image](///////blogs

/

/

/

/

first-malware/image-20241016152120-uh0qf2u.png)

![image](///////blogs

/

/

/

/

first-malware/image-20241016152208-3ffpdor.png)

![image](///////blogs

/

/

/

/

first-malware/image-20241016152708-osqqph4.png)

![image](///////blogs

/

/

/

/

first-malware/image-20241016152404-faa1jvd.png)

![image](///////blogs

/

/

/

/

first-malware/image-20241016152500-2cpzqdg.png)

```
jq -r '.. | .api?' capa.json | sort -u | less

```

![image](///////blogs

/

/

/

/

first-malware/image-20241020202225-xwkz7ga.png)

```
rsi=0000000002E2DD20 "uri=ads.php;exec=cexe;file=elif;conf=fnoc;exit=tixe;encode=5b;sleep=30000"
```

