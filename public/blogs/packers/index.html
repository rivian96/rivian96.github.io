<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=33751&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Packers | Rahul Mishra</title>
<meta name=keywords content><meta name=description content="Packing is like wrapping a program in layers to hide its contents. Malware authors use packers&mldr;
Packing is like wrapping a program in layers to hide its contents. Malware authors use packers to compress or encrypt the original program and add a small unpacking stub. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub decompresses (or decrypts) the real malicious code into memory and then hands control to it (courses."><meta name=author content="Me"><link rel=canonical href=//localhost:33751/blogs/packers/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=//localhost:33751/favicon.ico><link rel=icon type=image/png sizes=16x16 href=//localhost:33751/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=//localhost:33751/favicon-32x32.png><link rel=apple-touch-icon href=//localhost:33751/apple-touch-icon.png><link rel=mask-icon href=//localhost:33751/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=//localhost:33751/blogs/packers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Packers"><meta property="og:description" content="Packing is like wrapping a program in layers to hide its contents. Malware authors use packers&mldr;
Packing is like wrapping a program in layers to hide its contents. Malware authors use packers to compress or encrypt the original program and add a small unpacking stub. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub decompresses (or decrypts) the real malicious code into memory and then hands control to it (courses."><meta property="og:type" content="article"><meta property="og:url" content="//localhost:33751/blogs/packers/"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-05-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-05T00:00:00+00:00"><meta property="og:site_name" content="Rahul Mishra"><meta name=twitter:card content="summary"><meta name=twitter:title content="Packers"><meta name=twitter:description content="Packing is like wrapping a program in layers to hide its contents. Malware authors use packers&mldr;
Packing is like wrapping a program in layers to hide its contents. Malware authors use packers to compress or encrypt the original program and add a small unpacking stub. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub decompresses (or decrypts) the real malicious code into memory and then hands control to it (courses."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"//localhost:33751/blogs/"},{"@type":"ListItem","position":2,"name":"Packers","item":"//localhost:33751/blogs/packers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Packers","name":"Packers","description":"Packing is like wrapping a program in layers to hide its contents. Malware authors use packers\u0026hellip;\nPacking is like wrapping a program in layers to hide its contents. Malware authors use packers to compress or encrypt the original program and add a small unpacking stub. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub decompresses (or decrypts) the real malicious code into memory and then hands control to it (courses.","keywords":[],"articleBody":"Packing is like wrapping a program in layers to hide its contents. Malware authors use packers…\nPacking is like wrapping a program in layers to hide its contents. Malware authors use packers to compress or encrypt the original program and add a small unpacking stub. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub decompresses (or decrypts) the real malicious code into memory and then hands control to it (courses.cs.umbc.edu ,redscan.com). This means on disk you only see a wrapper, not the actual malware. Packing makes static analysis very hard, because the real code (and its strings or import table) stays hidden until runtime.\nOriginal Program (on disk) +------------+-----------+ | .text (code) | .idata | | .rdata (.data) | | ... (other sections) | +------------------------+ Entry point here ⬇︎ Packed Program (on disk after packing) +----------------------+ | Stub (decompressor) | \u003c-- contains code to unpack | Compressed data | (the original code encrypted) | (filler/empty space) | +----------------------+ Entry point is at Stub ⬇︎ ‍\nStep 1 – Packing: The packer takes the original executable (with its code, data, imports, etc.) and compresses or encrypts its contents. It then creates a new executable with a new header and stub. For example, UPX (a common packer) names its sections UPX0​, UPX1​, etc., instead of .text​ or .data​redscan.com​medium.com. The original entry point (OEP) of the program is replaced by the packer stub. This stub is a tiny loader program whose job is to restore the original program in memory7orvs.github.io courses.cs.umbc.edu.\n‍\nPacking process: (Original EXE) --pack--\u003e [Stub + EncryptedData] --save--\u003e (Packed EXE) ‍\nStep 2 – Stub Execution: When you run the packed executable, the operating system loads this stub into memory and begins executing it. The stub allocates memory, decompresses or decrypts the original program into that space, and rebuilds the import table and other metadata. In other words, it “unzips” the malicious payload in RAM. For instance, UPX’s stub will call functions like VirtualProtect​, LoadLibraryA​, and GetProcAddress​ to set permissions and resolve imports medium.com redscan.com. Finally, the stub jumps to the now-unpacked original entry point (OEP), transferring control to the real malware code7orvs.github.io redscan.com.\n‍\nRuntime unpacking (in memory): [OS loads packed EXE] ---\u003e [Stub runs] | v Stub does: - Allocate memory space - Decompress original code into it - Fix up Import Table (using LoadLibrary/GetProcAddress) - Jump to Original Entry Point After this: [Memory: Original code runs] ‍\nBecause of all this, static disassembly or decompilation on the packed file just shows the stub code and garbage data. The actual malicious logic is hidden. That’s why experts say packers *“make static analysis difficult as the original program will be obfuscated in packed form”*​redscan.com.\nDynamic Analysis and Unpacking In contrast, dynamic analysis (running the malware in a controlled environment) can reveal the unpacked code. When the packed malware is executed (for example in a virtual machine or sandbox), the unpacking stub decompresses the original code into memory. At that point the real malware code and its imports exist in memory, and one can inspect them.\nPractically, an analyst might set a breakpoint at the Original Entry Point. Since the stub transfers control there after unpacking, hitting that breakpoint means unpacking is done. Tools like OllyDbg or x64dbg can be used to dump the process memory after the stub finishes. Another trick is to break on memory-protection APIs (VirtualProtect​) that stub uses, because right after that call the real code is unpacked. Once dumped, the file in memory looks like the original (or close to it) and can be statically analyzed furtherredscan.com​7orvs.github.io.\n‍\nRuntime Flow Diagram: Packed EXE (disk) --\u003e Stub runs (allocates memory, unpacks code, fixes imports) --\u003e Original code executes in memory Runtime [Disk] [Memory after unpack] +------------+ +------------------+ | Stub code | -----\u003e | Unpacked .text | (Original code) | Compressed | | Unpacked .data | (Data restored) | data blob | | IAT rebuilt | (Imports resolved) +------------+ +------------------+ ‍\nDynamic analysis tools may still be tricked if the packer includes anti-debugging checks. Some packers check for debuggers/virtual machines (by looking at CPU flags, special hardware ports, or timing differences) and will behave differently if detected. Others deliberately generate code that confuses disassemblers (like overlapping instructions or self-modifying code). These techniques are more advanced layers: for example, a packer might execute a few real instructions, then jump backwards and execute them differently, foiling linear disassembly7orvs.github.io.\n‍\nAnti-Debug and Anti-Disassembly Tricks Beyond simply compressing code, many malware packers also add anti-analysis features:\nDebugger Detection: The unpacking stub might call Windows APIs like IsDebuggerPresent()​ or check the PEB BeingDebugged flag. It can deliberately trap single-step or breakpoints. For example, it might execute an illegal instruction (INT 3​) inside a try-catch block to see if a debugger catches it. Junk and Overlapping Code: The stub may contain garbage bytes or misleading jumps so that static disassemblers can’t parse straight through. An example is using JMP​ to skip over random bytes or creating code that only makes sense when executed sequentially. This confuses tools like IDA or Ghidra. Anti-VM/Sandbox Checks: Some packers query hardware or OS properties (e.g. disk serial numbers, MAC addresses, or CPU timestamp counters) that behave differently under virtualization. They might not unpack fully if they suspect a sandbox. Self-Modification: The stub might decrypt or modify parts of its own code at runtime in small chunks, so even stepping through with a debugger is harder without knowing exactly where. These tricks only slow down analysis; they cannot hide the code forever. Eventually, if the code runs, an analyst can trace through the unpacking stub, dump memory, and recover the payload7orvs.github.io​redscan.com. But they do make the process much more tedious.\nLayered Understanding Beginner: At first glance, a packed malware file is like an envelope hiding a letter. You only see the envelope (stub + gibberish), not the letter inside (real code). You must open the envelope (run the unpacker) to read the letter. Intermediate: Technically, the packer replaces the PE header and sections. On disk you lose the usual layout (.text, .data, .rdata). Everything goes into one or two sections. The stub then rebuilds the usual layout in memory. Advanced: The unpacking stub is effectively doing runtime linking. It mimics what the Windows loader usually does for imports, but manually with LoadLibrary/GetProcAddress​. It also often calls VirtualProtect​ to change memory permissions (so the unpacked code can execute). After all fixes, it jumps to the original code’s start. At that point, the malware runs normally, but now in memory instead of from disk. Throughout this process, packing hides section names, strings, and import tables. The original .text​ section becomes encrypted data. The .rdata​ (import) section may be minimal or gone. Analysts scanning the packed file statically see almost nothing of value: as noted, “few readable strings” and “imports resolved using runtime linking” are key signs of packingcourses.cs.umbc.edu​redscan.com. Only by letting the program unpack itself (under careful observation) can one restore the original view.\nIn summary, packers wrap malware in a hidden layer. On disk you see only a stub that does the heavy lifting. When run, the stub unpacks the real code into memory and then lets it execute. Packing thwarts static analysis (because code, strings, imports are hidden or scrambledcourses.cs.umbc.edu​redscan.com) and can include anti-debug tricks. Dynamic analysis is the usual way to unveil the packed content: a debugger or unpacking tool follows the stub’s actions until the malware is revealed.\nSources: Packing/unpacking concepts are well documented in malware analysis resources courses.cs.umbc.edu 7orvs.github.io redscan.com courses.cs.umbc.edu. These explain the stub mechanism, the effect on PE sections, and why static tools see only the unpacker, not the real code. The challenges to static analysis (hidden imports, strings, section names) are likewise noted by experts redscan.com redscan.com courses.cs.umbc.edu.\n","wordCount":"1296","inLanguage":"en","datePublished":"2025-05-05T00:00:00Z","dateModified":"2025-05-05T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"//localhost:33751/blogs/packers/"},"publisher":{"@type":"Organization","name":"Rahul Mishra","logo":{"@type":"ImageObject","url":"//localhost:33751/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=//localhost:33751/ accesskey=h title="Home (Alt + H)"><img src=//localhost:33751/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=//localhost:33751/blogs/ title=blogs><span>blogs</span></a></li><li><a href=//localhost:33751/projects/ title=projects><span>projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=//localhost:33751/>Home</a>&nbsp;»&nbsp;<a href=//localhost:33751/blogs/>Blogs</a></div><h1 class="post-title entry-hint-parent">Packers</h1><div class=post-meta><span title='2025-05-05 00:00:00 +0000 UTC'>May 5, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1296 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blogs/Packers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Packing is like wrapping a program in layers to hide its contents. Malware authors use packers&mldr;</p><p><strong>Packing</strong> is like wrapping a program in layers to hide its contents. Malware authors use packers to <strong>compress or encrypt</strong> the original program and add a small <strong>unpacking stub</strong>. The stub is a tiny piece of code that runs first. When the packed file is executed, the stub <strong>decompresses</strong> (or decrypts) the real malicious code into memory and then hands control to it (<a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/CMSC%20449%20-%20Lec3%20-%20Hashing%20and%20Packing.pdf#:~:text=%EF%82%A7%20Compress%20original%20program%20and,into%20memory%20and%20runs%20it">courses.cs.umbc.edu</a> ,<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=Software%20packers%20function%20by%20compressing,a%20decoder%20stub%20for%20decompression">redscan.com</a>). This means on disk you only see a wrapper, not the actual malware. Packing makes static analysis very hard, because the real code (and its strings or import table) stays hidden until runtime.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mathematica data-lang=mathematica><span class=line><span class=cl><span class=n>Original</span><span class=w> </span><span class=n>Program</span><span class=w> </span><span class=p>(</span><span class=n>on</span><span class=w> </span><span class=n>disk</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+------------+-----------+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=err>.</span><span class=n>text</span><span class=w> </span><span class=p>(</span><span class=n>code</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=err>.</span><span class=n>idata</span><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=err>.</span><span class=n>rdata</span><span class=w> </span><span class=p>(</span><span class=err>.</span><span class=n>data</span><span class=p>)</span><span class=w>         </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=err>...</span><span class=w> </span><span class=p>(</span><span class=n>other</span><span class=w> </span><span class=n>sections</span><span class=p>)</span><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+------------------------+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Entry</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=n>here</span><span class=w> </span><span class=err>⬇︎</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Packed</span><span class=w> </span><span class=n>Program</span><span class=w> </span><span class=p>(</span><span class=n>on</span><span class=w> </span><span class=n>disk</span><span class=w> </span><span class=n>after</span><span class=w> </span><span class=n>packing</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+----------------------+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>Stub</span><span class=w> </span><span class=p>(</span><span class=n>decompressor</span><span class=p>)</span><span class=w>  </span><span class=o>|</span><span class=w>  </span><span class=o>&lt;--</span><span class=w> </span><span class=n>contains</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>unpack</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>Compressed</span><span class=w> </span><span class=n>data</span><span class=w>      </span><span class=o>|</span><span class=w>  </span><span class=p>(</span><span class=n>the</span><span class=w> </span><span class=n>original</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=n>encrypted</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>filler</span><span class=o>/</span><span class=n>empty</span><span class=w> </span><span class=n>space</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+----------------------+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Entry</span><span class=w> </span><span class=n>point</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>Stub</span><span class=w> </span><span class=err>⬇︎</span><span class=w>
</span></span></span></code></pre></div><p>‍</p><p><strong>Step 1 – Packing:</strong> The packer takes the original executable (with its code, data, imports, etc.) and <strong>compresses or encrypts</strong> its contents. It then creates a new executable with a <strong>new header and stub</strong>. For example, UPX (a common packer) names its sections <code>UPX0</code>​, <code>UPX1</code>​, etc., instead of <code>.text</code>​ or <code>.data</code>​<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20next%20image%20shows%20sections,109%20Image%3A%20How%20to">redscan.com</a>​<a href="https://medium.com/ax1al/packing-and-obfuscation-fe6b03bbc267#:~:text=Upx%20is%20commonly%20used%20packer,3%20main%20part%20which%20are">medium.com</a>. The original entry point (OEP) of the program is replaced by the packer stub. This stub is a tiny loader program whose job is to restore the original program in memory<a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=A%20,to%20decrypt%20the%20packed%20file">7orvs.github.io</a> <a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/CMSC%20449%20-%20Lec3%20-%20Hashing%20and%20Packing.pdf#:~:text=%EF%82%A7%20Compress%20original%20program%20and,into%20memory%20and%20runs%20it">courses.cs.umbc.edu</a>.</p><p>‍</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mathematica data-lang=mathematica><span class=line><span class=cl><span class=n>Packing</span><span class=w> </span><span class=n>process</span><span class=err>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>(</span><span class=n>Original</span><span class=w> </span><span class=n>EXE</span><span class=p>)</span><span class=w> </span><span class=o>--</span><span class=n>pack</span><span class=o>--&gt;</span><span class=w> </span><span class=p>[</span><span class=n>Stub</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>EncryptedData</span><span class=p>]</span><span class=w> </span><span class=o>--</span><span class=n>save</span><span class=o>--&gt;</span><span class=w> </span><span class=p>(</span><span class=n>Packed</span><span class=w> </span><span class=n>EXE</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>‍</p><p><strong>Step 2 – Stub Execution:</strong> When you run the packed executable, the operating system loads this stub into memory and begins executing it. The stub <strong>allocates memory</strong>, <strong>decompresses or decrypts</strong> the original program into that space, and <strong>rebuilds the import table and other metadata</strong>. In other words, it “unzips” the malicious payload in RAM. For instance, UPX’s stub will call functions like <code>VirtualProtect</code>​, <code>LoadLibraryA</code>​, and <code>GetProcAddress</code>​ to set permissions and resolve imports <a href="https://medium.com/ax1al/packing-and-obfuscation-fe6b03bbc267#:~:text=After%20unpacking%20the%20original%20code,the%20help%20of%20debugger">medium.com</a> <a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=In%20this%20example%2C%20PEiD%20confirms,small%20number%20of%20text%20strings">redscan.com</a>. Finally, the stub jumps to the now-unpacked original entry point (OEP), transferring control to the real malware code<a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=And%2C%20the%20unpacking%20stub%20performs,three%20steps">7orvs.github.io</a> <a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20next%20step%20is%20to,return%20to%20the%20program%E2%80%99s%20OEP">redscan.com</a>.</p><p>‍</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mathematica data-lang=mathematica><span class=line><span class=cl><span class=n>Runtime</span><span class=w> </span><span class=n>unpacking</span><span class=w> </span><span class=p>(</span><span class=n>in</span><span class=w> </span><span class=n>memory</span><span class=p>)</span><span class=err>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>[</span><span class=n>OS</span><span class=w> </span><span class=n>loads</span><span class=w> </span><span class=n>packed</span><span class=w> </span><span class=n>EXE</span><span class=p>]</span><span class=w> </span><span class=o>---&gt;</span><span class=w> </span><span class=p>[</span><span class=n>Stub</span><span class=w> </span><span class=n>runs</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>v</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Stub</span><span class=w> </span><span class=n>does</span><span class=err>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-</span><span class=w> </span><span class=n>Allocate</span><span class=w> </span><span class=n>memory</span><span class=w> </span><span class=n>space</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-</span><span class=w> </span><span class=n>Decompress</span><span class=w> </span><span class=n>original</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=n>into</span><span class=w> </span><span class=n>it</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-</span><span class=w> </span><span class=n>Fix</span><span class=w> </span><span class=n>up</span><span class=w> </span><span class=n>Import</span><span class=w> </span><span class=n>Table</span><span class=w> </span><span class=p>(</span><span class=n>using</span><span class=w> </span><span class=n>LoadLibrary</span><span class=o>/</span><span class=n>GetProcAddress</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-</span><span class=w> </span><span class=n>Jump</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>Original</span><span class=w> </span><span class=n>Entry</span><span class=w> </span><span class=n>Point</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>After</span><span class=w> </span><span class=n>this</span><span class=err>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>[</span><span class=n>Memory</span><span class=err>:</span><span class=w> </span><span class=n>Original</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=n>runs</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><p>‍</p><p>Because of all this, static disassembly or decompilation on the packed file just shows the stub code and garbage data. The actual malicious logic is hidden. That’s why experts say packers *“make static analysis difficult as the original program will be obfuscated in packed form”*​<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20use%20of%20packers%20makes,it%20remains%20in%20packed%20form">redscan.com</a>.</p><h3 id=dynamic-analysis-and-unpacking>Dynamic Analysis and Unpacking<a hidden class=anchor aria-hidden=true href=#dynamic-analysis-and-unpacking>#</a></h3><p>In contrast, <strong>dynamic analysis</strong> (running the malware in a controlled environment) can reveal the unpacked code. When the packed malware is executed (for example in a virtual machine or sandbox), the unpacking stub decompresses the original code into memory. At that point the real malware code and its imports exist in memory, and one can inspect them.</p><p>Practically, an analyst might set a breakpoint at the Original Entry Point. Since the stub transfers control there after unpacking, hitting that breakpoint means unpacking is done. Tools like OllyDbg or x64dbg can be used to dump the process memory after the stub finishes. Another trick is to break on memory-protection APIs (<code>VirtualProtect</code>​) that stub uses, because right after that call the real code is unpacked. Once dumped, the file in memory looks like the original (or close to it) and can be statically analyzed further<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20next%20step%20is%20to,return%20to%20the%20program%E2%80%99s%20OEP">redscan.com</a>​<a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=And%2C%20the%20unpacking%20stub%20performs,three%20steps">7orvs.github.io</a>.</p><p>‍</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mathematica data-lang=mathematica><span class=line><span class=cl><span class=n>Runtime</span><span class=w> </span><span class=n>Flow</span><span class=w> </span><span class=n>Diagram</span><span class=err>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Packed</span><span class=w> </span><span class=n>EXE</span><span class=w> </span><span class=p>(</span><span class=n>disk</span><span class=p>)</span><span class=w>  </span><span class=o>--&gt;</span><span class=w>  </span><span class=n>Stub</span><span class=w> </span><span class=n>runs</span><span class=w> </span><span class=p>(</span><span class=n>allocates</span><span class=w> </span><span class=n>memory</span><span class=p>,</span><span class=w> </span><span class=n>unpacks</span><span class=w> </span><span class=n>code</span><span class=p>,</span><span class=w> </span><span class=n>fixes</span><span class=w> </span><span class=n>imports</span><span class=p>)</span><span class=w>  </span><span class=o>--&gt;</span><span class=w>  </span><span class=n>Original</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=n>executes</span><span class=w> </span><span class=n>in</span><span class=w> </span><span class=n>memory</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>Runtime</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>[</span><span class=n>Disk</span><span class=p>]</span><span class=w>               </span><span class=p>[</span><span class=n>Memory</span><span class=w> </span><span class=n>after</span><span class=w> </span><span class=n>unpack</span><span class=p>]</span><span class=w>               
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+------------+</span><span class=w>        </span><span class=o>+------------------+</span><span class=w>                  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>Stub</span><span class=w> </span><span class=n>code</span><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=o>-----&gt;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Unpacked</span><span class=w> </span><span class=err>.</span><span class=n>text</span><span class=w>   </span><span class=o>|</span><span class=w>  </span><span class=p>(</span><span class=n>Original</span><span class=w> </span><span class=n>code</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>Compressed</span><span class=w> </span><span class=o>|</span><span class=w>        </span><span class=o>|</span><span class=w> </span><span class=n>Unpacked</span><span class=w> </span><span class=err>.</span><span class=n>data</span><span class=w>   </span><span class=o>|</span><span class=w>  </span><span class=p>(</span><span class=n>Data</span><span class=w> </span><span class=n>restored</span><span class=p>)</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=n>blob</span><span class=w>  </span><span class=o>|</span><span class=w>        </span><span class=o>|</span><span class=w> </span><span class=n>IAT</span><span class=w> </span><span class=n>rebuilt</span><span class=w>      </span><span class=o>|</span><span class=w>  </span><span class=p>(</span><span class=n>Imports</span><span class=w> </span><span class=n>resolved</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>+------------+</span><span class=w>        </span><span class=o>+------------------+</span><span class=w>                  
</span></span></span></code></pre></div><p>‍</p><p>Dynamic analysis tools may still be tricked if the packer includes anti-debugging checks. Some packers check for debuggers/virtual machines (by looking at CPU flags, special hardware ports, or timing differences) and will behave differently if detected. Others deliberately generate code that confuses disassemblers (like overlapping instructions or self-modifying code). These techniques are more advanced layers: for example, a packer might execute a few real instructions, then jump backwards and execute them differently, foiling linear disassembly<a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=A%20,to%20decrypt%20the%20packed%20file">7orvs.github.io</a>.</p><p>‍</p><h3 id=anti-debug-and-anti-disassembly-tricks>Anti-Debug and Anti-Disassembly Tricks<a hidden class=anchor aria-hidden=true href=#anti-debug-and-anti-disassembly-tricks>#</a></h3><p>Beyond simply compressing code, many malware packers also add <strong>anti-analysis features</strong>:</p><ul><li><strong>Debugger Detection:</strong> The unpacking stub might call Windows APIs like <code>IsDebuggerPresent()</code>​ or check the <strong>PEB BeingDebugged flag</strong>. It can deliberately trap single-step or breakpoints. For example, it might execute an illegal instruction (<code>INT 3</code>​) inside a try-catch block to see if a debugger catches it.</li><li><strong>Junk and Overlapping Code:</strong> The stub may contain garbage bytes or misleading jumps so that static disassemblers can’t parse straight through. An example is using <code>JMP</code>​ to skip over random bytes or creating code that only makes sense when executed sequentially. This confuses tools like IDA or Ghidra.</li><li><strong>Anti-VM/Sandbox Checks:</strong> Some packers query hardware or OS properties (e.g. disk serial numbers, MAC addresses, or CPU timestamp counters) that behave differently under virtualization. They might not unpack fully if they suspect a sandbox.</li><li><strong>Self-Modification:</strong> The stub might decrypt or modify parts of its own code at runtime in small chunks, so even stepping through with a debugger is harder without knowing exactly where.</li></ul><p>These tricks <strong>only slow down</strong> analysis; they cannot hide the code forever. Eventually, if the code runs, an analyst can trace through the unpacking stub, dump memory, and recover the payload<a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=And%2C%20the%20unpacking%20stub%20performs,three%20steps">7orvs.github.io</a>​<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20next%20step%20is%20to,return%20to%20the%20program%E2%80%99s%20OEP">redscan.com</a>. But they do make the process much more tedious.</p><h3 id=layered-understanding>Layered Understanding<a hidden class=anchor aria-hidden=true href=#layered-understanding>#</a></h3><ul><li><strong>Beginner:</strong> At first glance, a packed malware file is like an <strong>envelope</strong> hiding a letter. You only see the envelope (stub + gibberish), not the letter inside (real code). You must open the envelope (run the unpacker) to read the letter.</li><li><strong>Intermediate:</strong> Technically, the packer <strong>replaces the PE header and sections</strong>. On disk you lose the usual layout (.text, .data, .rdata). Everything goes into one or two sections. The stub then rebuilds the usual layout in memory.</li><li><strong>Advanced:</strong> The unpacking stub is effectively doing <strong>runtime linking</strong>. It mimics what the Windows loader usually does for imports, but manually with <code>LoadLibrary/GetProcAddress</code>​. It also often calls <code>VirtualProtect</code>​ to change memory permissions (so the unpacked code can execute). After all fixes, it jumps to the original code’s start. At that point, the malware runs normally, but now <em>in memory</em> instead of from disk.</li></ul><p>Throughout this process, packing <strong>hides section names, strings, and import tables</strong>. The original <code>.text</code>​ section becomes encrypted data. The <code>.rdata</code>​ (import) section may be minimal or gone. Analysts scanning the packed file statically see almost nothing of value: as noted, <em>“few readable strings”</em> and <em>“imports resolved using runtime linking”</em> are key signs of packing<a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/Basic%20Static%20Analysis.pdf#:~:text=How%20Packers%20Work">courses.cs.umbc.edu</a>​<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=In%20this%20example%2C%20PEiD%20confirms,small%20number%20of%20text%20strings">redscan.com</a>. Only by letting the program unpack itself (under careful observation) can one restore the original view.</p><p>In summary, packers wrap malware in a hidden layer. On disk you see only a stub that does the heavy lifting. When run, the stub unpacks the real code into memory and then lets it execute. Packing thwarts static analysis (because code, strings, imports are hidden or scrambled<a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/Basic%20Static%20Analysis.pdf#:~:text=17%20%EF%82%A7%20Malware%20authors%20want,code%20%EF%81%B1%20Strings%20%EF%81%B1%20Imports">courses.cs.umbc.edu</a>​<a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=In%20this%20example%2C%20PEiD%20confirms,small%20number%20of%20text%20strings">redscan.com</a>) and can include anti-debug tricks. Dynamic analysis is the usual way to unveil the packed content: a debugger or unpacking tool follows the stub’s actions until the malware is revealed.</p><p><strong>Sources:</strong> Packing/unpacking concepts are well documented in malware analysis resources <a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/CMSC%20449%20-%20Lec3%20-%20Hashing%20and%20Packing.pdf#:~:text=%EF%82%A7%20Compress%20original%20program%20and,into%20memory%20and%20runs%20it">courses.cs.umbc.edu</a> <a href="https://7orvs.github.io/tutorials%20summaries/packing-notes-part1/#:~:text=And%2C%20the%20unpacking%20stub%20performs,three%20steps">7orvs.github.io</a> <a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=Software%20packers%20function%20by%20compressing,a%20decoder%20stub%20for%20decompression">redscan.com</a> <a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/Basic%20Static%20Analysis.pdf#:~:text=17%20%EF%82%A7%20Malware%20authors%20want,code%20%EF%81%B1%20Strings%20%EF%81%B1%20Imports">courses.cs.umbc.edu</a>. These explain the stub mechanism, the effect on PE sections, and why static tools see only the unpacker, not the real code. The challenges to static analysis (hidden imports, strings, section names) are likewise noted by experts <a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=The%20next%20image%20shows%20sections,109%20Image%3A%20How%20to">redscan.com</a> <a href="https://www.redscan.com/news/redscan-labs-malware-unpacking-uncover-hidden-cyber-threats/#:~:text=In%20this%20example%2C%20PEiD%20confirms,small%20number%20of%20text%20strings">redscan.com</a> <a href="https://courses.cs.umbc.edu/undergraduate/CMSC491malware/Basic%20Static%20Analysis.pdf#:~:text=17%20%EF%82%A7%20Malware%20authors%20want,code%20%EF%81%B1%20Strings%20%EF%81%B1%20Imports">courses.cs.umbc.edu</a>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=//localhost:33751/blogs/unpacking-malware/><span class=title>« Prev</span><br><span>Unpacking Malware</span>
</a><a class=next href=//localhost:33751/blogs/analysing-my-first-malware/><span class=title>Next »</span><br><span>Analysing My First Malware</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on x" href="https://x.com/intent/tweet/?text=Packers&amp;url=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f&amp;title=Packers&amp;summary=Packers&amp;source=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on reddit" href="https://reddit.com/submit?url=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f&title=Packers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on facebook" href="https://facebook.com/sharer/sharer.php?u=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on whatsapp" href="https://api.whatsapp.com/send?text=Packers%20-%20%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on telegram" href="https://telegram.me/share/url?text=Packers&amp;url=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Packers on ycombinator" href="https://news.ycombinator.com/submitlink?t=Packers&u=%2f%2flocalhost%3a33751%2fblogs%2fpackers%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=//localhost:33751/>Rahul Mishra</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>